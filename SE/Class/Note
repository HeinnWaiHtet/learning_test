Encapsulation
ဆိုတာက data hiding, preventing invalid data processing
တွေကိုသုံးဖို့တွက်ဖြစ်တယ်။

software design မှာ အဓီကကျတဲ့ ၂ခုရှိတယ်။
အဲ့တာက cohesion နဲ့ coupling
cohesionဆိုတာက ကိုဘ့်ဒေတာနဲ့ကိုသုံးတာဖြစ်တယ်။
ဥပမာဆိုရင် တိုင်းပြည်တပြည်က ကိုယ့်နိုင်ငံက အလုံးစုံထွက်ပီး ကိုယ့်ထွက်ကုန်နဲ့ကိုသုံးနိုင် သူများကိုမှီခိုစရာမလိုတာမျိုးဖြစ်တယ်။
အဲ့လိုပဲ class တခုက ကိုယ့်method , properties တွေကိုပဲသုံးတာဖြစ်တယ်။
အခြားမှီခိုစရာမရှိတော့ unit test တွဲလဲကောင်းတယ်။

couplingကျတော့ အခြားကောင်ကိုမှီခိုနေတာဖြစ်တယ်။
အဲ့လိုမှီခိုနေတာဆိုတော့မှီခိုနေတဲ့ကောင်ပေါ်မူတည်ပီး ပြဿနာဖြစ်နိုင်ခြေများတယ်။
အဲ့တာမို့ဖြစ်နိုင်ရင် coupling ဖြစ်နိုင်တာကို လျော့နိုင်သမျှလျော့သင့်တယ်။

choesionများပီး coupling နည်းသင့်တယ်။

coupling မှာမှ tight coupling & loose coupling ဆိုတာရှိတယ်။

-------------------------

Occam razorရဲ့သီအိုရီအရ proof တွေကိုပြတဲ့အခါမှာ အရိုးရှင်းဆုံးက အကောင်းဆုံးပဲ
အဲ့တာမို့ဖြစ်နိုင်ရင် ကုဒ်ရေးရင်လဲ အရိုးရှင်းဆု့းဖြစ်သင့်တယ်။

-------------------------
Councurrent Vs Parallel
concurrent ဆိုတာက အလုပ်လုပ်နေတဲ့အခါမှာ အခြားအလုပ်လုပ်နေတဲ့အခါကို အလုပ်လုပ်နိုင်တာဖြစ်တယ်။
အဲ့လိုမှီခိုနေတာကို concurrent လို့ခေါ်တယ်။

Parallel
Multiple CPU, Multiple Core
Run at the same time
ပြောချင်တာက CPUတခုရှိတယ်ဆိုရင် တကြိမ်မှာ အလုပ်တခုပဲလုပ်နိုင်မယ်။
CPU 2ခုရှိရင် တကြိမ်ထဲမှာ အလုပ်နှစ်ခုတခါတည်းလုပ်နိုင်တယ်။
အဲ့တာကို parallel လို့ခေါ်တယ်။

concurrent ဆိုတာကကျတော့ CPUတခုရှိတယ် အဲ့ပေါ်မှာမှ thread
တွေ တခုပီးမှ တခုrunတယ်။ ပြောချင်တာက Thread 1ပီးမှ
Thread 2ကိုလုပ်တယ်။ အဲ့လိုမျိုးတခုပီးမှ တခုဖြစ်တယ်။
ဥပမာ လူရဲ့စိတ်လိုပဲ ဒါပေမဲ့ တခုပီးမှ တခုဖြစ်တယ်ဆိုပေမဲ့
အရမ်းမြန်လွန်းလို့ တခါတည်းဖြစ်နေတယ်လို့ထင်နေရတယ်။
အဲ့တာကို concurrent လို့ခေါ်တယ်။

why thread & multi Programming
ဟိုးအရင်က MSDOSခေတ်တုနး်ကဆိုရင် တကြိမ်မှာ တခုပဲအလုပ်လုပ်နိုင်တယ်။
တကြိမ်မှာ one process ပဲလုပ်နိုင်တယ်။
အဲ့တာကို single Programming လို့ခေါ်တယ်။
ပြောချင်တာက CPU အလုပ်လုပ်ချင်လုပ်ဒါမှမဟုတ်ရင် IO processလုပ်။
အဲ့ချိန်မှာ latency (ကြာချိန်)ကိုသိဖို့လိုတယ်။
CPUက အလုပ်လုပ်တာမြန်တယ်။
IOက အလုပ်လုပ်တာနှေးတယ်။
အဲ့အချိန်မှာ ဥပမာအားဖြင့် process တခုက IOလုပ်နေရင် CPUက အားနေတယ်။
အဲ့အချိန်မှာ CPU ကိုအခြားprocessပေးသု့းလို့ရတယ်။
အဲ့တာက multi programming, multi threading လို့ခေါ်တယ်။

concurrencyသည် အမြဲတမ်း performance ကိုimproveဖြစ်တဘ်ဆိုတာ
မဟုတ်ဘူး။
တခုတလေကြရင် OOP language တွေမှာ concurrency ကြောင့် mutual execution
problem ဆိုတာတွေဖြစ်နို်ငတယ်။
ဥပမာပြောရမယ်ဆိုရင် thread ၃ ကိုသုံးပီး counter ကို တိုးတယ်ဆိုရင်
loop 1သိန်းပတ်တယ်ဆိုရင် ၃သိန်းမရပဲ data lossဖြစ်ပီး အခြားဒေတာတခုရနိုင်တယ်။
ပြောချင်တာက mutliple thread က same dataကိုလှမ်းရိုက်ရင်
data atomic မဖြစ်နိုင်ဘူး။
ဘယ်လိုလုပ်သွားလို့လဲဆိုရင် byte code level မှာဆိုရင်
အောက်ကလို လုပ်သွားလို့ဖြစ်တယ်။
load value
inc value
store value
အဲ့လိုမျိုး thread 1,2,3ကနေ တခုတည်းကိုပဲ incrementကို ၀ိုင်းလုပ်ကြလို့ဖြစ်တယ်။
အဲ့လိုမျိုး ပြဿနာကို mutual exclusion လို့ခေါ်တယ်။
အဲ့လိုပြဿနမျိုးကို java မှာဆိုရင် synnchronized ကိုသုံးပီးဖြေရှင်းလို့၇တယ်။




