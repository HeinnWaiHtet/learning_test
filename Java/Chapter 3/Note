strongly type - ဆိုတာက invalid operationတွေကို ပေးမလုပ်ဘူး type error cacheလုပ်နိုင်တယ်
   ဒါပေမဲ့ ဘယ်လောက် stronglyဖြစ်တယ်ဆိုတာ languageပေါ မူတည်တယ် 
   ဥပမာ C++ and java နဲ့မှာဆို java က ပိုပီး stronglyဖြစ်တယ်လို့ပြောလိုရတယ်
   
   အောက်ကဥပမာကိုကြည့်ရအောင်
   Java
   int a = 10;
   a = "Hello" * 10; // Error

   JavaScript
   let a = 10;
   a = "Hello" * 10; // Not Error but Will get invalid value
   ဒီဥပမာမှာဆိုရင် Java မှာဆို a က number ဖြစ်နေတဲ့ အတွက်ကြောင့်
   invalid type operationဖြစ်တဲ့ string တန်ဖိုးနဲ့ မြှောက်တာမျိုးကို လုပ်ဆောင်လို့ရမှာမဟုတ်ဘူးဖြစ်တယ်။
   ဒါပေမဲ့ JavaScriptမှာကျတော့ခွင့်ပြုတယ် ဒါပေမဲ့ တန်ဖိုးကျတော့ 
   မှန်ကန်တဲ့ operationမဟုတ်တဲ့အတွက် invalid value တန်ဖိုးတွေထွက်မှာဖြစ်တယ်။
   အဲ့လိုကောင်မျိုးကို ဆိုလိုတာဖြစ်တယ်။

   အဲ့လို Invalid Operation တွေပေးလုပ်တာမျိုးကိုကျတော့ weakly type လို့ခေါ်တယ်။
   strongly type ဆိုတာက invalid type operation တွေကို program runနေတဲ့ချိန်မှာကော
   မ run ခင်နိုင်မှာကော သိနိုင်ပီး ကာကွယ်နိုင်တာမျိုးကို ခေါ်ဆိုတာဖြစ်တယ်။

Strongly & weakly typeဖြစ်ခြင်းမဖြစ်ခြင်းသည် static or dynamic type
နဲ့မသတ်ဆိုင်ပဲ invalid type operation ကို ခွင့်ပြုချင်းမပြုခြင်းနဲ့တာဆိုင်တယ်။
Dynamic typeဖြစ်ပေမဲ့ Strongly typeဖြစ်တဲ့ language တွေလဲရှိတယ်။
ဥပမာဆိုရင် ruby လိုကောင်မျိုးပေ့ါ။

What is Type.
ဒီနေရာမှာ typeဆိုတာက ဘာကိုပြောချင်တာလဲဆိုရင် ဒေတာကို လက်ခံနိုင်တဲ့ပုံစံအမျိုးအစားကိုဆိုလိုတာဖြစ်တယ်။
ပြောချင်တာက ကိန်းဂဏန်းတွေလား။ စာသားတွေလား။ အစရှိသည်ဖြင့်ပေါ့။

Type တွေကိုက static programming languageတွေမှာပဲ ခွဲတာများတယ်။
dynamic programming languageတွေမှာလဲရှိတယ် ဒါပေမဲ့ ဒီလိုမျိုးမခွဲကျဘူး။

အဲ့တော့ Type ရှိတာ ဘာထူးခြားလဲပေ့ါ။ သူက တာ၀န်၂ခုကို လုပ်ဆောင်တယ်။
၁။ set of possible values(လက်ခံနိုင်တဲ့ တန်ဖိုးတွေကိုသတ်မှတ်ချင်း)
ဥပမာ အနေနဲ့ဆို ရေထည့်မှာလား အစားစာတွေထည့်မှာလား အဲ့လိုမျိုးကိုဆိုလိုတာဖြစ်တယ်။
၂။ set of possible operations(ဘယ်လိုမျိုးလုပ်ဆောင်ချက်တွေလုပ်ဆောင်မှာလဲ)
ဥပမာ အနေနဲ့ဆို ကိန်းဂဏန်းတွေဆို ပေါင်းနုတ်မြှောက်စားပေးမယ်။
ဒါပေမဲ့ စာသားတွေကိုကျတော့ ပေါင်းနုတ်မြှောက်စားမပေးဘူး။
အဲ့လိုမျိုးကိုဆိုလိုတာဖြစ်တယ်။
နောက်ဥပမာနေနဲ့ဆို ရေခွက်ဆိုဘာလုပ်လို့ရမလဲ ရေထည့်လို့ရမယ်။ အခြား အရွက်တွေလှီးဖို့ ဓားလိုသုံးမရဘူး။
အဲ့လိုပဲ ဓားဆိုလဲ အရွက်တွေ အသားတွေလှိးဖို့သုံးရမယ်ရေထည့်လို့မရဘူး အဲ့လိုမျိုး
အမျိုးစားပေါ်မူတည်ပီး လုပ်ဆောင်ချက်တွေ ခွဲထားတာမျိုးကို ဆိုလိုတာဖြစ်တယ်။

Java မှာဆို Primitive and Reference typeဆိုပီး Type ၂မျိုးရှိတယ်။
Primitive typeဆိုတာက အသေးဆုံး ထပ်ခွဲလို့မရတဲ့ typeမျိုးကိုခေါ်တာဖြစ်တယ်။
Reference typeမှာကျတော့ ထပ်ခွဲလို့ရသေးပီး သူ့မှာ Primitive typeတွေလဲပါ၀င်နိုင်တယ်။
 ဥပမာနေနဲ့အောက်က ကုဒ်လေးကိုကြည့်ရအောင်
 class Human{
    String name;
    int age;
 }

 ဒီမှာဆို name, ageတွက်သတ်မှတ်ထားတဲ့ string, intတို့ကို Primitive typeလို့ခေါ်ပီး
 class Human ဆိုတာကျတော့ Reference typeလို့ခေါ်တယ်။

Primitive Type မှာမှ
Interger - အပြည့်ကိန်းတန်ဖိုးများသိမ်းရန်
Floating point number - ဒဿမတန်ဖိုးများသိန်းရန်
Characters - စာလုံးတန်ဖိုးများသိမ်းရန်
Boolean - မှန်လားမှားလားလိုမျိုး flagတန်ဖိုး(true, false)သိမ်းရန်ဆိုပီး ၄မျိုးရှိတယ်။

Intergers မှာမှ byte, short, int, longဆိိုပီးရှိတယ်။
ဘာကွာလဲဆိုရင် size ကွာတယ် လက်ခံနိုင်တဲ့ပမာဏပေါ့။
byte ကိုတာသုံးရင် -128 ကနေ 127ကြားကတန်ဖိုးတွေကိုသိမ်းနိုင်တယ်။
short ဆို –32,768 ကနေ 32,767
int ဆို –2,147,483,648 ကနေ 2,147,483,647
long ဆို –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
အဲ့တော့ ကိုယ့်ရဲ့လိုအပ်တဲ့ပမာဏပေါ်မူတည်ပီး ဘယ်ကောင်နဲ့ဆိုကိုက်ညီလဲရွေးချယ်နိုင်တယ်။
byte bvalue = 20;
short svalue = 20;
int value = 20;
long lvalue = 20;

နောက်တခုက Floating-point numbers
သူ့မှာဆို Float & double ဆိုပီး ၂မျိုးရှိတယ်။သူလဲ sizeကွာတာပဲဖြစ်တယ်။
double ဆို 4.9e–324 ကနေ 1.8e+308
float ဆို 1.4e–045 ကနေ 3.4e+038
double dvalue = 3.45;
float fvalue = 2.34f;

Charactersဆိုတာကကျတော့ A, B, Cအဲ့လိုမျိုး တန်ဖိုးတွေလက်ခံနိုင်တဲ့typeမျိုးကိုခေါ်တာဖြစ်တယ်။
character ထဲမှာဆို စာလုံးတလုံးပဲလက်ခံနိုင်တာဖြစ်တယ်။
char ch = 'A';

Booleanဆိုတာကကျတော့ မှန်လားမှားလားဆိုတဲ့ true, false တန်ဖိုးတွေကို သိမ်းချင်ရင် သုံးနိုင်တယ်။
bool isTrue = true;

အဲ့ Primitive typeထဲကမဟုတ်ဘူးဆို ကျန်တဲ့ typeအမျိုးစားတွေကိုဆိုရင် reference type
လို့မှတ်သားနိုင်ပါတယ်။

Java program တခုမှဆိုရင် class တခုရှိပီး entry point(စပီး အလုပ်လုပ်မဲ့နေရာ)အနေနဲ့
main methodတခုရှိရမယ် အောက်က ဥပမာကို လေ့လာကြည့်ရအောင်

public class SE{
    public static void main(String[] args){
        System.out.println("Hello World");
    }
}

ဒီကုဒ်မှာဆို public static void mainဆိုတဲ့ကောင်က ဒီကုဒ်ရဲ့၀င်ပေါက်ဖြစ်ပီး 
အဲ့ကုဒ်အောက်ကရှိတဲ့ {}အဖွင့်ပိတ်ကြားက ကုဒ်လိုင်းတွေကို လုပ်ဆောင်ပေးသွားမှာဖြစ်တယ်။
ဒီဥပမာကို runကြည့်လိုက်မယ်ဆိုရင်တော့ consoleမှာ "Hello World"ဆိုတဲ့ စာသားလေးပြမှာပဲဖြစ်တယ်။


What is Variable?
variable ကိုမပြောခင်ဒီဥပမာလေးကိုကြည့်ရအောင်
public class SE{
    public static void main(String[] args){
        System.out.println(10 + 20);
        System.out.println(10 - 20);
        System.out.println(10 * 20);
        System.out.println(10 / 20);
    }
}

ဒီကောင်မှာဆိုရင် ၁၀နဲ့ ၂၀ဆိုတဲ့တန်ဖိုးပေါ်မှာမူတည်ပီးတော့ ပေါင်းနှုတ်မြှောက်စားဆိုတဲ့
လုပ်ဆောင်ချက်ကိုလုပ်ထားတယ်။ ဟုတ်ပီခုလိုမျိုး အမြဲမပြောင်းလဲတဲ့ အရာမျိုးဆို ဘာမှမဖြစ်ပေမဲ့
တချိန်မှာ ၁၀က နေ ၂၀၀ဆိုပီးပြောင်းဖို့လိုလာပီဆို ဘာလုပ်မလဲ ၁၀ကို ရေးထားတဲ့နေရာတိုင်းလိုက်ပြင်နေရတော့မယ်။
တကယ်လို့ အဲ့ကောင်ကတာ နေရာ အခုသုံးလေးဆယ်လောက်ကနေခေါ်ထား ခေါ်ထားတဲ့နေရာအားလုံးလိုက်ပြင်ရမယ်။
အဲ့တော့ဘာဖြစ်နိုင်လဲဆို​ အချိန်တွေကုန်တယ် နောက်တခုက မေ့ပီး တချို့နေရာတွေ ကျန်နေခဲ့တာဖြစ်နိုင်တယ်။
အဲ့တော့ အဲ့လိုဖြစ်ရပ်မျိုးအတွက်ဆို variableဆိုတာကိုသုံးပီး ဖြေရှင်းနိုင်တယ်။

variableဆိုတာ ထပ်ကာထပ်ကာ အသုံးပြုမဲ့တန်ဖိုးတွေကို 
အဲ့လိုမျိုးသုံးရင် နောင်ကျ ပြင်ဖို့မလွယ်, အမြဲထပ်တလဲလဲ 
ပြန်ခေါ်ကြေညာသုံးနေရတဲ့ ပြသနာတွေကို ဖြေရှင်းဖို့ တန်ဖိုး(value)တွေကို 
label တခုနေနဲ့ သတ်မှတ်ပီး ပြန်ခေါ်သုံးခြင်းကိုဆိုလိုတယ်။
vaiableတွေကို memoryပေါ်မှာ သိမ်းထားတာဖြစ်တယ်။ အဲ့တာကိုတော့ Java languageက 
အလိုအလျောက်စီမံပေးမှာဖြစ်တယ်။ သူ့ကို မသုံးတော့တဲ့နေရာရောက်ရင်တော့
memory ပေါ်ကနေပီး အလိုလျောက် ဖြတ်ချသွားမှာဖြစ်တယ်။

vaiable တခုကို အောက်ပါနည်းလမ်းတွေအတိုင်းကြေညာနိုင်တယ်။
vaiableType vaiableName; // int num;
variableType vaiableName = Type Related Value; // int num = 10;
တခုထပ်မကတဲ့ type တူတဲ့ variableတွေကို ဆက်တိုက်ကြေညာချင်ရင် comma(,)ခံပီးကြညာလို့ရတယ်။
eg. int num1, num2;
int num1 = 10, num2 = 20;
အထက်ပါ ပုစာကို vaiable နဲ့ပြန်ပြင်မယ်ဆိုအောက်ပါတိုင်းရေးလို့ရတယ်။

public class SE{
    public static void main(String[] args){
        int num1 = 10;
        int num2 = 20;
        System.out.println(num1 + num2);
        System.out.println(num1 - num2);
        System.out.println(num1 * num2);
        System.out.println(num1 / num2);
    }
}

ဒီလိုပြင်ရေးလိုက်တဲ့တွက် တချိန်မှာ ၁၀ကနေ ၂၀၀ပြောင်းချင်ရင်တနေရာထဲ ပြင်လိုက်တာနဲ့
ကျန်တဲ့ နေရာတိုင်းလိုက်ပြင်ဖို့မလိုပဲ မြန်ဆန်ပီး လွယ်လွယ်ကူကူလုပ်ဆောင်နိုင်မှာပဲဖြစ်တယ်။

static type programmingတွေမှာဆို vaiable မှာက type ရှိပီး
dynamic type programmingတွေမှာဆိုရင်ကျတော့ typeကို value ကနေသတ်မှတ်တာဖြစ်တယ်။
Static Type
int num = 10; // number type

Dynamic Type
let num = 10; // number type
num = true; // boolean type
num = "Hello"; // string type

Java program တခုကိုrun ရင် static and dyanmic type checking ဆိုပီး ၂မျိုးလုပ်တယ်။
static type checking ကို compile time မှာလုပ်ပီး dynamic type checking ကို runtime မှာလုပ်တယ်။
compile time ဆိုတာက program ကိုရေးနေချိန်နဲ့ javac ဆိုပီး command နဲ့runတဲ့ချိန်ကိုပြောတာဖြစ်တယ်။
ဘယ်လိုမျိုးဟာတွေကို check ပေးတာလဲဆိုရင် invalid typeတွေထည့်နေတာလား 
syntax တွေမှားနေတာလားဆိုတာမျိုးကို check ပေးတာမျိုးကိုဆိုလိုတယ်။
syntaxမှားနေတာလားဆိုတဲ့ အဓိပာယ်က ဥပမာပေးရမယ်ဆို
java program တွေမှာဆို ကုဒ်ရဲ့အဆုံးတိုင်းမှာ semicomma(;)ပါရမယ်
အဲ့ကောင်တွေသေချာပါနေရဲ့လား ဒါမျိုးစစ်ပေးတာကို ဆိုလိုတာဖြစ်တယ်။
တကယ်လို့ ကိုယ့်ရဲ့ကုဒ်က compile time error ရှိနေတယ်ဆိုရင် run လို့ရမှာမဟုတ်ပါဘူး။

နောက်တခုက dyanmic type checking အဲ့ကောင်က ဘယ်လိုမျိုးလဲဆိုရင် 
ကိုယ့်ရဲ့ program က runနေပီ runနေတော့မှ array index boundကျော်သွားတာလား
အဲ့လိုမျိုးစစ်ပေးတာမျိုးကိုဆိုလိုတာဖြစ်တယ် လောဆယ် array ဆိုတာ မပြောရသေးတဲ့တွက်
ဒီအတိုင်းပဲ မှတ်ထားလိုက်ပါဥိး။

byte
byte က -128 ကနေ 127ထိပဲဆန့်တယ် အဲ့ချိန်မှာ တကယ်လို့ ၁၂၇ထပ်ကျော်သွားရင်ရော
ဘာဖြစ်နိုင်မလဲဆိုတော့ bound ကျော်သွားတဲ့တွက်ကြောင့် unexpected result တွေရနိုင်တယ်။
ဥပမာ ကြည့်ကြရအောင်
byte num = 127; // 127
num++; // -128
ဒီနေရာမှာ num++ဆိုတာက numကို ၁တိုးလိုက်မယ်လို့ဆိုလိုတာဖြစ်တယ်။
သူ့ရဲ့ အများဆုံးလက်ခံနိုင်တဲ့ပမာဏက ၁၂၇ကို ၁ထပ်တိုးလိုက်တဲ့အချိန်မှာ ၁၂၈ဆိုတာမရပဲ
-၁၂၈ဆိုတဲ့ negativeတန်ဖိုးကိုရသွားတာကိုတွေ့ရမှာဖြစ်တယ်။
အဲ့လိုကိစမျိုးကို သတိထားဖို့လိုအပ်တယ်။
ဒါမို့ကိုယ့်ရဲ့ သုံးမယ့် တန်ဖိုးက ဘယ်လောက်ပမာဏလဲဆိုတာ သိရှိပီး သင့်တော်တဲ့ data type
ကိုရွေးချယ်ဖို့လိုအပ်ပါတယ်။

ကျန်တဲ့type တွေဖြစ်တဲ့ short, int, longလဲ အလားတူထဲပဲဖြစ်တယ်။

Float
ဒဿမကိန်းတွေသိမ်းချင်ရင် float ကို အသုံးပြုနိုင်တယ်။
သူ့ကို ကြေညာသုံးမယ်ဆို အောက်ကလို ကြေညာပီးသုံးနိုင်တယ်။
float price = 1.2F;
float price = 1.2f;

အနောက်က floatဆိုတာကို ကိုယ်စားပြုတဲ့ f or F ကိုထည့်ပေးဖို့လိုအပ်တယ်။

doubleကို ကြေညာဖို့ဆိုရင်တော့ နောက်က postfixကိုထည့်ပေးစရာမလိုပါဘူး
double နဲ့ float ဆို double က ပိုများတဲ့ အရေတွက်ကို လက်ခံနိုင်တဲ့ပုံစံအမျိုးအစားကိုဆိုလိုတာဖြစ်တယ်။
ကြေညာပီးအသုံးပြုမယ်ဆို အောက်ပါတိုင်းအသုံးပြုနိုင်တယ်။
double pi = 3.14;

Characters
အက်ခရာ တလုံးတည်းသိမ်းချင်တဲ့ ကိစ်မျိုးကိုဆိုရင် char ကိုအသုံးပြုလို့ရတယ်။
အောက်ပါပုံစံတိုင်း ကြေညာဖို့လိုအပ်ပါတယ်။
char ch = 'A';
သိမ်းချင်တဲ့ ကောင်ကို single quote('')ထဲမှာထည့်ရေးရတယ်။
အက်ခရာ တလုံးတည်းပဲ ထည့်ရမှာဖြစ်တယ်။
character တွေက ကွန်ပျူတာမှာနောက်ကွယ်မှာ binary နေနဲ့သိမ်းတဲ့တွက်
သူ့ကို number တန်ဖိုးနေနဲ့ သိမ်းလို့ရတယ်။ ဥပမာဆို Aရဲ့ ascii represent valueဟာ
65 ဖြစ်တဲ့အတွက်ကြောင့် 
char ch = 65;ဆိုရင်လဲ ပြန်ထုတ်ကြည့်ရင် Aရမှာပဲဖြစ်တယ်။
ဒါမို့ character ဟာလဲ number typeထဲမှာ ပါတာဖြစ်တယ်။

character ဟာ unicode ကိုလဲ support ပေးတာဖြစ်တဲ့တွက်ကြောင့်
char ch = 'က'; 
ဆိုတာမျိုးကိုလည်း ထည့်ပီးလုပ်ဆောင်နိုင်ပါတယ်။

Boolean
ကို မှန်လားမှားလားဆိုတဲ့ ကိစ်မျိုးမှာ မှန်မှား အခြေအနေတွေကို true, falseနဲ့ 
သတ်မှတ်ဖော်ပြချင်တဲ့ နေရာမျိုးမှာသုံးတယ်။
boolean found = true;
boolean found = false;
ဆိုပီး အသုံးပြုနိုင်တယ်။

အထက်မှာပြောခဲ့သလို type က value and operation ကို သတ်မှတ်ပေးတာဖြစ်တဲ့တွက်ကြောင့်
char ch = 'A';
ch++;
System.out.println(ch); // B

boolean found = true;
found++; // Error

character ဟာဆိုရင် number type အမျိုးစားဖြစ်တဲ့တွက်ကြောင့် 1တိုးတယ်ဆိုတဲ့
operation မျိုးလုပ်ဆောင်နိုင်ပါပေမဲ့
boolean ကတော့ number calcuation operationတွေကို မလုပ်ဆောင်နိုင်ပဲ
invalid type operation error တက်မှာပဲဖြစ်တယ်။

Literals
-ဆိုတာက value, constantမျိုးကိုခေါ်တာဖြစ်တယ်။
တနည်းပြောရမယ်ဆိုရင် တိုက်ရိုက်သုံးတဲ့ အချက်အလက်ကိုဆိုလိုတာဖြစ်တယ်။
ဥပမာဆို 1, 2 ဒါဆို integer lateral,
1.2F ဒါဆို float lateral
3.14, .3E2 ဒါဆို double lateral
true, false ဒါဆို boolean lateral
ဟုတ်ပီ အဲ့မှာမှ နောက်ထပ် နည်းနည်းပြောကြည့်ရအောင်

ပုံမှန် integer ကိုကြေညာနေတာက decimal format ဖြစ်တယ် 
အဲ့တာကိုမှ haxadecimal format(0x prefix) ကိုအသုံးပြုပီး lateral နေနဲ့ ကြေညာသုံးမယ်ဆို
အောက်ပါတိုင်းအသုံးပြုလို့ရတယ်။
int hex = 0xFF; //255
ဒီကောင်ကို ထုတ်ကြည့်မယ်ဆိုရင်တော့ decimal 255ဆိုတာရမှာဖြစ်တယ်။


အဲ့လိုပဲ binary တွက်ဆိုရင် 0b,
ocatal တွက်ဆို 0ကိုအသုံးပြုပီး lateralနည်းနဲ့ ကြေညာပီးသုံးနိုင်တယ်။
int binary = 0b101; // 5
int oct = 0105; // 69

binary, ocatal, haxadecimal ကနေ decimal ပြောင်းနည်းကိုတော့
ဒိမှာမပြောတော့ပါဘူး ရေဘုံယျအားဖြင့် binary မှာဆို 0,1,
ocatalမှာဆို 0-7, haxadecimalမှာဆို 0-9A-Fကို အသုံးပြုရနိုင်တယ်ဆိုတာမှတ်ထားပါ။
ဘယ်လိုပြောင်းတယ်ဆိုတာကတော့ မိမိဘာသာ တချက် ဆက်လက်လေ့လာကြည့်ဖို့ ပြောကြားလိုပါတယ်။

ပိုက်ဆံပမာဏ အများပြားလို ကိန်းဂဏန်းတွေဆိုရင် ကြားထဲမှာ underscoreခံပီး
lateral ကိုရေးပီးကြေညာလို့ရပါတယ်. javaရဲ့ compiler က အဲ့တာ large number
or ဖတ်ရလွယ်ဖို့တွက်ဆိုတာ အလိုလျောက်နားလည်တဲ့တွက်ပြဿနာရှာမှာမဟုတ်ပါဘူး
eg. int bigNum = 123_456_789;

float and double lateral
floating point lateral နဲ့ကြေညာမယ်ဆို f or Fဆိုတာနဲ့ကြေညာပေးဖို့လိုတယ်
eg. float pi = 3.14F;

double lateral မှာဆိုရင်တော့ postfix ထည့်စရာ မလိုပဲကြေညာလို့ရပါတယ်။
double pi = 3.14;

တကယ်လို့ အရှေ့က ကိန်းပြည့်က 0ဆိုရင် ကိန်းပြည့်ကို မထည့်ပဲလဲ အောက်ပါတိုင်းကြေညာလို့ရပါတယ်။
double d = .4; // 0.4

floating point မှာလဲ underscoreခံပီး အသုံးပြုနိုင်တယ်။

Characters lateral
-မှာဆိုရင် ဒီလိုမျိုး ကြေညာ အသုံးပြုနိုင်တယ်။
char ch = 'A';
တကယ်လို့ single codeကိုသုံးချင်တယ်ဆိုရင်
ch = '''
ဆိုပီး အသုံးပြုလို့မရဘူး အဲဲ့တော့ သုံလို့ရအောင် escape လုပ်ဖို့လိုတယ်။
backslashကို အသုံးပြုပီး escape လုပ်ပီး အသုံးပြုနိုင်တယ်။
ch = '\''
အဲ့လိုမျိုး အသုံးပြုနိုင်ပါတယ်။

String lateral
- ဆိုရင် double quote("")နဲ့ရေးရတယ်။ characterတလုံးထပ် ပိုတာကြေညာချင်ရင်
string lateral ကိုသုံးပီးကြေညာနိုင်တယ်။ String သည် reference typeအမျိုးအစား
ဖြစ်တယ်။
eg.
String str = "Hello World";

Static Typeတွေမှာက vaiable တွေကို သုံးမယ်ဆိုရင် ကြေကိုကြေညာဖို့လိုတယ်။
မကြေညာပဲသုံးလို့မရဘူး။

vaiableတွေကိုကြေညာမယ်ဆိုရင် အောက်ပါပုံစံတိုင်းကြေညာနိုင်တယ်
type identifier [ = value ][, identifier [= value ] …];
[] ဆိုတာက ပါလဲရတယ် မပါလဲရတယ်ဆိုတဲ့ သဘောတရားပဲဖြစ်တယ်။

ဥပမာအနေနဲ့ဆို အောက်ကလိုမျိုးပဲဖြစ်တယ်။
int a;
int a = 10, b = 20;
int a, b = 30;

boolean found = true; လိုမျိုး variable ကြေညာထဲက တန်ဖိုးပေးလိုက်တာကို
initializationလို့ခေါ်တယ်။

int a = 10, b = 20;
int c = a + b;
အဲ့လိုမျိုး latearl ကိုတိုက်ရိုက်မထည့်ပဲနဲ့ calcuationတခုခုလုပ်ပီးမှ ထည့်တာမျိုးကို
dynamic initializationလို့ခေါ်တယ်။

What is Scope?
နောက်ပီး vaiableတွေမှာ scopeဆိုတာရှိတယ်။
ဘာကိုပြောတာလဲဆိုရင် နယ်ပယ်အကျယ်အ၀န်းကိုပြောတာဖြစ်တယ်။ ဘယ်နေရာကနေ 
ဘယ်နေရာအထိ အဲ့ကောင်ကို သု့းလို့ရတယ်ဆိုတာမျိုးကို ဆိုလိုတာဖြစ်တယ်။

Java မှာရှိတဲ့ကောင်က block scope ဖြစ်တယ် ဆိုလိုတာက variable တခုကို စကြေညာတဲ့
အပေါ်က { ကနေ သူ့အဆုံး } ထိ သူ့ကို သုံးလို့ရတယ်။
အောက်က ဥပမာကိုကြည့်ရအောင်။

public class Scope {
    public static void main(String[] args) {
        int num = 10;
        {
            int num1 = 20;
            System.out.println(num1);
            System.out.println(num);
        }
            System.out.println(num1); // Error no scope for num1
            System.out.println(num);
    }
}

ဒီဥပမာမှာဆိုရင် num ဆိုတဲ့ကောင်ကို အပေါ်ဆုံး scope မှာကြေညာထားတဲ့
အဲ့အတွက် သူ့ကို num1ကြေညာထားတဲ့ အထဲမှာကော အပြင်မှာပါ ခေါ်သုံးလို့ရတယ်။
ဒါပေမဲ့ num1မှာဆိုရင်ကျတော့ သူ့ကို သူ့ကိုကြေညာထားတဲ့ scopeထဲမှာဆိုသုံးလို့ရတယ်
ဒါပေမဲ့ သူ့ရဲ့ အပြင် scope ကနေခေါ်ရင်တော့ သူက မရှိတော့တဲ့အတွက် 
Error တက်မှာပဲဖြစ်တယ်။ အဲ့လိုမျိုး scope က variable ၁လုံးဟာ ဘယ်အချိန်ထိ
အသက်ရှိနေတယ်ဆိုတာကို သတ်မှတ်ပေးတာပဲဖြစ်တယ်။

variable ၁ခုကို စတင်ကြေညာတဲ့အချိန်ကနေပီး သူ့ကိုနောက်ဆုံး accessလုပ်လို့ရတဲ့အထိကို
variable ၁ခုရဲ့ lifetimeလို့ခေါ်တယ်။
နောက်တခုက variable ၁လုံးကို နာမည်တူနဲ့ scope မကုန်မခြင်း ပြန်ကြေညာလို့မရဘူး 
ဥပမာကြည့်ကြရအောင်
public class Scope {
    public static void main(String[] args) {
        int num = 10;
        {
            int num1 = 20;
            int num = 30; // Error Cannot Declare
            System.out.println(num1);
            System.out.println(num);
        }
        
            int num1 = 30; // OK Scope End in upper block
            System.out.println(num1);
            System.out.println(num);
    }
}

ဒီဥပမာမှာဆို num = 30;ဆိိုတဲ့အချိန်မှာ variable ရဲ့ scope ဟာရှိသေးတဲ့တွက် ပြန်ကြေညာလို့မရဘူး
ဒါပေမဲ့ int num1 = 30; မှာတော့ num1 ဆိုတဲ့ကောင်က အပေါ်က block ပီးသွားရင် မရှိတော့တာဖြစ်တဲ့တွက်
ပြန်လည်ကြေညာပီး အသုံးပြုလို့ရပါတယ်။

Type Conversion and Casting
Type Conversion ဆိုတာက Type ၁ခုကနေ အခြားType ၁ခုကိုပြောင်းတာမျိုးကိုခေါ်တယ်။
Type Conversion လုပ်ဖို့ဆိုရင် rule 2ခုပြေလည်ဖို့လိုတယ်။

၁. Type 2 ခုလုံးက compatibleဖြစ်ရမယ်။ ဘာကိုပြောတာလဲဆိုရင် number typeအမျိုးစားတွေကိုဆိုရင်
အခြားနောက်တခုကလဲ number typeပဲဖြစ်ရမယ်။
အခြား boolean တို့ Stringတို့မဖြစ်ရဘူး

၂. destination type(အထည့်ခံရမယ့်ကောင်)က source type(ထည့်မဲ့) type အမျိုးအစားထက် ကြီးရမယ်
ဘယ်လိုမျိုးပြောချင်တာလဲဆို nuber typeမှာ byte, short, int, longဆိိုပီးရှိတယ်။
long ထဲကို int, short, byte ထည့်လိုရတယ်။
ဒါပေမဲ့ int ထဲကို long ထည့်လို့မရဘူး byte, short တော့ထည့်လို့ရမယ်။
ဘာလို့လဲဆိုရင် long မှာ လက်ခံနိုင်တဲ့ ပမာဏက int ထပ်များတော့ တကဘ်လို့တာ ထည့်လိုက်မယ်ဆို
ဒေတာတွေပျောက်ဆုံးသွားတာတွေဖြစ်နိုင်လို့ပဲဖြစ်တယ်။

Type Casting ဆိုတာကကျတော့ ခုဏက ငယ်တဲ့ type ထဲကို ကြီးတဲ့ type ထည့်ချင်ရင် 
သုံးလို့ရတာမျိုးကို ခေါ်တယ်။ ဒါပေမဲ့ ဘာဆိုးကြီးရှိလဲဆိုရင် လက်ခံနိုင်တဲ့ ပမာဏထပ်
ပိုများသွားတဲ့ကောင်မျိုးဆိုရင် ဒေတာပျောက်သွားတာတွေဖြစ်သွားနိုင်တယ်။
ဥပမာနှင့်တကွ ကြည့်ကြရအောင်

public class TypeConversion {
    public static void main(String[] args) {
        char ch = 'A';
        int num = ch;
        
        System.out.println(num); // 65
        short s = num; // cannot assign

        String str = "Hello";
        int num1 = str;
        
        // Type Casting
        byte b = (byte)num;
        
    }
}

ပထမဆုံးနေနဲ့ type conversion ဒီမှာဆိုရင် ပထမ character typeကနေပီး 
integer အနေနဲ့ပြောင်းလိုက်တယ် integer ဟာ character ထပ်ပိုကြီးတဲ့အတွက်ကြောင့် ပြောင်းလဲလို့ရတယ်။
ထုတ်ကြည့်လိုက်မယ်ဆို 'A'ရဲ့ ASCII value ဟာ ၆၅ဖြစ်တဲ့တွက် ထုတ်ကြည့်ရင် ၆၅ဆိုတဲ့ တန်ဖိုးကို ၇မှာပဲဖြစ်တယ်။

short s = num; 
ဒီကောင်မှာဆိုရင် integer ကနေ short ထဲကို ထည့်လိုက်တယ် ဒါပေမဲ့ ထည့်လို့မရဘူး
run မယ်ဆိုရင် error တက်မှာပဲဖြစ်တယ် ဘာလို့ဆို destination typeထပ်  source typeကကြီးနေလို့ပဲဖြစ်တယ်။

int num1 = str;
ဒီကောင်မှာဆိုရင် string typeကနေ integer typeထဲထည့်လိုက်တယ်ဆိုရင်လဲ 
error တက်မှာပဲဖြစ်တယ်။ ဘာလို့ဆိုရင် type compatible မဖြစ်တဲ့အတွက် ထည့်လို့မရတာပဲဖြစ်တယ်။

byte b = (byte)num;
ဒီမှာဆိုရင် byte ထဲကို interger တန်ဖိုးကို ထည့်လိုက်တာပဲဖြစ်တယ်။
ပုံမှန်ဆိုရင် ကြီးတဲ့တန်ဖိုးကို ငယ်တဲ့ထဲ ထည့်မယ်ဆိုရင် erorr တက်မှာ ဖြစ်တယ်။
ထည့်ချင်တဲ့ destination typeနဲ့ cast လုပ်ဖို့လိုတယ်။ ဒါပေမဲ့ type ကတော့
compatible ဖြစ်ဖို့လိုအပ်တယ်။ အဲ့လိုမျိုး ကြီးတဲ့type ကနေ ငယ်တဲ့type ထဲထည့်တာကို
type castingလို့ခေါ်တယ်။


























































































































