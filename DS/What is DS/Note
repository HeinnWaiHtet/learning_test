https://www.amazon.com/Data-Structures.../dp/0672324539
https://www.amazon.com/Introduction.../dp/0262033844
https://www.amazon.com/Computer-Programming.../dp/0321751043

Data Structure ဆိုတာက
Array, Linked List, Graph
Stack
Queue
Tree လိုကောင်မျိုးကိုခေါ်တာဖြစ်တယ်။
ပြောရမယ်ဆို ဒေတာကို ဘယ်လိုနည်းနဲ့ သိမ်းမယ် 
စွဲထုတ်မယ်ဆိုတာမျိုးပေါ့
Databaseမှာဆို B+ Tree လိုကောင်မျိုးကိုသုံးတယ်။
အဲ့ကောင်ကို သိဖို့ဆိုရင် B Tree ကိုသိဖိုလိုတယ်။
B Tree ကိုသိဖို့ဆို Tree ကိုသိဖို့လိုတယ်။
အဲလိုမျိုးအဆင့်ဆင့်သိဖို့လိုတယ်။
အဲ့တာမို့ DSကိုသိဖို့ဆို အခြေခံကောင်တွေ အဆင့်ဆင့်သိဖို့လိုအပ်တယ်။

Algorithm ဆိုတာက 
searching, sorting, tree traversal တို့လိုကောင်မျိုးကိုခေါ်တယ်။

Algorithm တွေကို ဘယ်ကောင်ပိုမြန်လဲတိုင်းဖို့ဆိုရင်
တင်ပီးrunတဲ့ hardwareပေါ်မှာ ဆုံးဖြတ်လို့မရဘူး
အဲ့ Algorithmရဲ့ complexity ပေါ်မှာပဲတိုင်းတာလို့ရမယ်။
Time Complexity, Space Complexity ဆိုတာကိုသိဖို့လိုတယ်။
အဲ့ကောင်တွေ ဘယ်လောက်ကြာလဲဆိုတဲ့ပေါ်မှာမူတည်ပီး ဆုံးဖြတ်ဖို့လိုတယ်။
အဲ့လိုမျိုး complexity timeတဲ့နည်းလမ်းကို 
Big O Notation လို့ခေါ်တယ်။
သူက ဘာကိုတိုင်းတာလဲဆိုရင် algorithm ရဲ့
worse caseကိုတိုင်းတယ် အဆိုးဆုံးခြေနေမှာတောင် 
ဘယ်လောက်ကြာလဲဆိုတာပေါ့။
အခြား best case, Average caseဆိုပီးလဲဆိုတာလည်းရှိတယ်။
ဒါပေမဲ့ worse caseကိုအဓိက သိဖို့လို့တယ်။
ဥပမာအနေနဲ့ဆို 
Algorithm 1 ကို run လို့ကြာတဲ့ချိန်က O(n)
Algorithm ၂ ကို run တဲ့ကြာချိန်က o(n*2)
အဲ့တာဆို အဆိုးဆုံးချိန်မှတောင် Algorithm 1က ကောင်းတယ်လို့
ပိုငယ်တယ်လို့ပြောလို့ရတယ်။
အဲ့မှာ n က ဘာလဲဆိုရင် number of inputs ကိုခေါ်တာဖြစ်တယ်။
ဥပမာ ဒိarray [1,2,3,4,5] ဆိုရင် n က 5ပဲဖြစ်တယ်။
Big Oသည် ဘယ်ပေါ်မှာ မူတည်ပီးတွက်လဲဆို n ပေါ်မှာမူတည်ပီး တွက်တာဖြစ်တယ်။
ပြောချင်တာက input 4 ကို ရှာတဲချိန်နဲ့ 100ကိုရှာတဲ့ကြာချိန်က တူမှာမဟုတ်ဘူး

အခြားတိုင်းတာတဲ့နည်းအနေနဲ့ Theda, Omegaတို့လဲရှိတယ်။
Theda ကကျတော့ဘာကိုပြောလဲဆိုရင် average ကြိမ်ထိအလုပ်လုပ်မဲ့ကောင်မျိုးကိုပြောချင်တာဖြစ်တယ်။
Omega ကကျတော့ best caseကို တိုင်းရင်ခေါ်တဲ့ အခေါ်၀ေါ်ဖြစ်တယ်။


Array
Insert, retrieveလွယ်တယ် မြန်တယ်။
constant timeဖြစ်တယ် ဘယ်လိုပြောမလဲဆို
O(1) - တကြိမ်ထဲလုပ်တာ ရှာချိန်မြန်တယ်လို့ပြောရမယ်ပေါ့။
arrayမှာ index ကိုသုံးပီးရှာတာလိုမျိုးမှာသုံးတယ်။
မကောင်းတာကျတော့ 
ရှာတာ ဖြတ်တာတွေကျတော့ နှေးတယ်
indexနဲ့ထည့်မယ်ရှာမယ်ဆို array ကိုသုံးသင့့်တယ်။

Ordered Array
ရှာရတာလွယ်တယ်။
ထည့်ရတာ ဖြတ်ရတာကျနှေးတယ်

Red Black Tree
ဒိေကာင်ကကျတော့ database လိုကောင်မျိုးမှာသုံးတယ် ရှာရတာမြန်တယ် 
ဒါပေမဲ့ complex ဖြစ်တယ်

hash
arrayက index နဲ့သွားတယ် hashက ကျတော့ keyနဲ့သွားတယ်
သူကလဲ O(1) ပဲ
searching time မြန်တယ်။

Algorithmတွေက ဘယ်ကောင်က ပိုမြန်လည်းဆိုတာ specific hardwareပေါ်မှာ တိုင်းလို့မရဘူး
တိုင်းမယ်ဆိုရင် Math နည်းအရတိုင်းရမယ်။
ဘယ်လိုခေါ်လဲဆိုရင် Big O Notationလို့ခေါ်တယ်။

Big O Notation
O ဆိုတာဘာကိုပြောလဲဆိုရင် orderကိုပြောတာ
ဘာပြောချင်တာလဲဆိုရင် rate of functionကို ပြောချင်တာဖြစ်တယ်။
ဘာကိုပြောချင်တာလဲဆိုရင် conditionally အရ functionက တက်သွားလားကျသွားလို့ဆိုတာမျိုး ဆုံးဖြတ်တာမျိုးကိုဆိုလိုတာဖြစ်တယ်။
အဲ့တာကိုဘာလို့ခေါ်လဲဆိုရင် Complexityလိုခေါ်တယ်
algorithm တွေမှာဆိုရင် complexity 2မျိုးရှိတယ်
time & space complexityဆိုပီးရှိတယ်။
timeဆိုတာက program runရအောင် CPU ဘယ်လောက်လိုတယ်ဆိုတာမျိုး
space ဆိုတာက memory ဘယ်လောက်လိုတယ်ဆိုတာမျိုးကိုတွက်တာကိုခေါ်တာဖြစ်တယ်။
Complexity
time ->CPU
space->memory

Orderကို ဘာနဲ့တိုင်းလဲဆိုရင် nနဲ့တိုင်းတယ်။
ဘာကိုပြောတာလဲဆိုရင် input sizeကိုခေါ်တာဖြစ်တယ်။
n -> input size
ဘာကိုပြောချင်တာလဲဆိုရင် ဥပမာ array [1,2, 3, 4, 5]ပေါ့ 
အဲ့မှာဆိုရင် input size 5အဲ့လိုမျိုးကောင်ကိုပြောချင်တာဖြစ်တယ်
ဆိုလိုတာက input အရေတွက်ကိုခေါ်တာဖြစ်တယ်။

time complexity ရဲ့ Order က ဘာကို တိုင်းလဲဆိုရင် iterateလုပ်တဲံ step အကြိမ်အရေတွက်ကို တိုင်းတာဖြစ်တယ်။
ဥပမာ arrayမှာ loopပတ်မယ်ဆို array အခန်းတခန်းချင်းစီ လျောက်သွားဖို့လိုတယ်
အဲ့ကျတော့ Orderတွက်မယ်ဆိုရင် O(n)ဆိုပီးဖြစ်မယ်။

Big -O->Order->worse case complexity?
Big 0ကို worst case complexityလို့ခေါ်တယ် ဆိုလိုတာက
[1,2, 3, 4, 5]ဆိုတဲ့ array မှာ -2ဆိုတာကိုရှာမယ် တကယ်လို့မတွေ့ဘူးဆိုရင်
နောက်ဆုံးအခန်းထိN အကြိမ်အရေတွက်ထိ ရှာဖို့လိုတယ်။
အဲ့တာကို worst case complxityလို့ပြောတာဖြစ်တယ်။
ပြောချင်တာက အဆိုးဆုံးအခြေနေကိုဆိုလိုတာဖြစ်တယ်။

Big o or Asymptotic Analysis - worst case
Big Theta (Θ) - Average Case
Big Omega - Best Case

Constant 
- ဆိုတာက ပြောရမယ်ဆိုရှာတယ်တန်းတွေ့တယ် ကြာချိန်က တိတိကျကျသိတာမျုိးကိုပြောတာဖြစ်တယ်
o(1) - log ထုတ်တာမျိုးကိုပြောတာဖြစ်တယ်။

O(n) 
Linear searchလိုကောင်မျိုးကိုပြောချင်တာဖြစ်တယ်။
input size n ကြိမ်ထိအလုပ်လုပ်မဲ့ကောင်မျိုးကိုပြောချင်တာဖြစ်တယ်။

O(n!)
ဘယ်လိုကောင်မျိုးလဲဆိုရင် ချဲတွက်တဲ့ကောင်မျိုးမှာရှိနိုင်တဲ့ possibility ကိုခေါ်တာဖြစ်တယ်။ 
permutaiton,combination လို့ခေါ်တယ်။
ပြောချင်တာက abcဆိုတဲ့ ကိန်းစဥ်တန်းမှာဆိုဖြစ်နိုင်တဲ့ pattern အရေတွက်ကို ပြောချင်တာဖြစ်တယ်။

Logarithmic time: O(n log n)
log ဆိုတာဘာလဲဆိုရင် number of powerကိုပြောချင်တာဖြစ်တယ်။
log လို့ပြောတာနဲ့ ဘာရှိရမယ်ဆုိရင် baseရှိရမယ်။
ဥပမာဆိုရင် 2ရဲ့ power ကိုရှာချင်ရင် ဘယ်လောက်လဲဆိုရင်ဆိုရင် အဲ့တာကိုပြောတာဖြစ်တယ်။
ဥပမာဆိုရင် 2 ** 3 = 8 မှာဆိုရင် 8သည် 2ရဲ့ power ဘယ်လောက်လဲဆိုတာမျိုးကို log လို့ခေါ်တယ်။
ဒီမှာဆိုရင် ကျတော့ log 3 ဆိုပီးပြောလို့ရတယ် အဲ့လိုမျိုးကောင်ကိုဆိုလိုတာဖြစ်တယ်။
n vs log n မှာ ဘယ်သူက ပိုငယ်လဲဆိုရင် log nက ပိုငယ်တယ်လို့ပြောလို့ရတယ်။
အဲ့တာမို့ log nက process time မှာပိုမြန်တယ်လို့ပြောလို့ရတယ်။
O(n) vs O(log n)နဲ့ဆို O(n)က  worse case ပိုကြီးတယ်။

Quadratic time: O(n^2)
- ဆိုတာက n ပေါ်မှာ power တင်တဲ့ကောင်မျိုးကို ခေါ်တယ်။
ဥပမာဆိုရင် tree 2ခုတိုက်တာမျိုးကိုဆိုလိုတာဖြစ်တယ်။
tree diffing algorithm လိုကောင်မျိုးကိုဆိုလိုတာဖြစ်တယ်။
react မှာဆို nodeတွေဘယ်လိုပြောင်းသွားလဲဆိုတာမျိုးကို စစ်တဲ့အခါမှာသုံးတဲ့ကောင်မျိုးဖြစ်တယ်။ 
အဲ့မှာတော့ complexityက O(n^3) ဖြစ်မယ်။
များသောအားဖြင့် sorting algorithmမျိုးတွေမှာသုံးတယ်။

heuristic algorithm
- ဆိုတာက အရင်ရှိနေတဲ့ ုဒေတာပေါ်မူတည်ပီးဘာဖြစ်မယ်ဆိုတာကို ဆိုံးဖြတ်တဲ့ကောင်မျိုးကို ဆိုလိုတာဖြစ်တယ်။

Exponential time: 2 ^(n)
- ဆိုတာက n က power နေရာမှာရျိနေတဲ့ကောင်မျိုးကိုဆိုလိုတာဖြစ်တယ်။

တချို့ algorithm တွေက time complexity, တချို့က space complexityပေါ်မှာ မူတည်ပီးကွဲတယ်
အဲ့တော့ ကိုဘာလုိအပ်တာလဲဆိုတာပေါ်မူတည်ပီး ရွေးချယ်သင့်တယ် ဥပမာ DBMSလိုကောင်မျိုးဆိုရင် space လိုအပ်တဲ့ပေါ်မူတည်ပီဂတွက်တဲ့ေကာ်ငမျိုးဆိုရင် space complexity algo B+ tree လိုကောင်မျိုးကိုရွေးချယ်သင့်တယ်။

static type langauge တွေမှာရှိတဲ့ array က size ကိုသတ်မှတ်ထားရတဲ့တွက်ကြောင့်
index အရ ထည့်မယ် ထုတ်မယ် ဖြတ်မယ်ဆိုရင် O(1)ပဲရှိတယ် အဲ့တာမို့မြန်တယ်လို့ပြောရမယ်။ indexနဲ့ပဲထည့်မယ် ထုတ်မယ်ဆို၇င် array ကိုသုံးသင့်တယ်။






























































