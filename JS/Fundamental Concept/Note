What is Program?
program ဆိုတာ လုပ်ငန်းစဥ်တခုကို စနစ်တကျ ဘာပီးဘာလုပ်တယ်ဆိုတာမျိုးကို ဖွဲ့စည်းထားတာြဖစ်တယ်

Programming language ဆိုတာက အဲ့လိုပဲ computer ကို ဘာလုပ်မယ်ဆိုတာ စနစ်တကျဖွဲ့စည်းဖို့ လုပ်ဆောင်ချက်တွေကို လူကနားလဉ်တဲ့ ဘာသာစကားကနေ ကွန်ပျူတာကို ခိုင်းစေနိုင်တဲ့ ဘာသာစကားဖြစ်တယ်

Compilerဆိုတာ လူနားလည်တဲ့ programming Languageကိုယူပီးရင် manchine နားလည်တဲ့ ဘာသာစကား(0,1)နေနဲ့ ပြောင်းပီး လုပ်ဆောင်ပေးတာမျိုးကိုခေါ်တယ် 

Javascript ကို FrontEnd(Mobile, Web Application using react, vue, angular), Backend(using Node, express, nuxt.js,etc), Desktop App(using Electron), Mobile(using React native, ionic)မှာ သုံးနိုင်တယ်

FrontEndဆိုတာ user မြင်ရတဲ့ ကောင်တွေကို လုပ်ဆောင်ပေးတာဖြစ်ပီး Backendဆိုတာ business logic and serviceတွေကို လုပ်ဆောင်ပေးတဲ့ ကောင်မျိုးကို ခေါ်တယ် 

Cloudပေါ်မှာ တင်ထားတဲ့ကောင်ကို SASS(Software as a service)လို့ခေါ်တယ် 

JSက front endမှာဆို browser မှာrunတယ်
backend မှာဆို Node မှာrunတယ် အဲ့တော့ runတဲ့စက်မှာ Nodeရှိနေဖို့လိုတယ် 

Browser မှာ ဘယ်လို runလဲဆိုရင် client server computingအရသွားတယ် 
ဥပမာနေနဲ့ဆို facebook ကိုလှမ်းပီး access လုပ်မယ်ဆို 
လူကနေပီး clientဖြစ်တဲ့ (web browser )ကိုသု့းပီး request 1ခုတောင်းလိုက်တဘ် ဥပမာနေနဲ့ www.facebook.com ပေါ့ 
အဲ့ request ကို server ဖြစ်တဲ့ HTTP, FTP, SMTPစတဲ့ ကောင်တွေကနေ လက်ခံရပီး user requestလုပ်လိုက်တဲ့ data ကို ပြန်ပေးပီး အဲ့ကောင်ကို user မြင်အောင် browser မှာ လူနားလည်တဲ့ UI(user interface)နေနဲ့ ပြန်ပေးတာကို ခေါ်တယ် 

အဲ့တော့ client and serverကြားမှာ ဘယ်လို ဆက်သွယ်လဉ်းပေါ့ ဘာလို့ဆို client က လှမ်းတောင်းလိုက်တာက machine(eg. window)မှာ ဒေတာတွေကို သိမ်းထားတဲ့ machine(eg. linux)ဆိုပီးရှိနေတဘ် အဲ့ ၂‌ေကာင်ကြား ဘယ်လိုဆက်သွယ်လဲပေါ့ 
အဲ့လို network(internet)ကိုသုံးပီး ဆက်သွယ်တာကို protocol လို့ခေါ်တယ် 
Web browser and web serverကြားဆက်သွယ်တဲ့ နည်းပညာကို HTTP protocolလို့ခေါ်တယ် ဘယ်လိုပြောမလဲဆို အဲ့နှစ်ခုကြား ဆက်သွယ်ရေးစာချူပ်လိုပေါ့
ဘယ်ပုံစံနဲ့ ပို့ရင် လက်ခံမယ် ဘယ်ဒေတာ ပြန်ပေးမဘ်ဆိုတဲ့ စာချုပ်လို ပု့စံမျိုးဖြစ်တယ် 
ဥပမာနေနဲ့ဆို Netcat Commandsကို သုံးပီး စမ်းကြည့်နိုင်တယ် 
nc www.google.com (connect to server)
GET / HTTP/1.0	 (request to server)
အဲ့အချီန်မှာ server request format တာမှန်မဘ်ဆို server က တောင်းလို်ကတဲ့ ဒေတာနဲ့ သက်ဆိုင်ရာ အချက်လက်တွေ ပြန်ပေးလိမ့်မယ် 
အဲ့‌ပြန်ရလာတဲ့ ဒေတာတွေကိုမှ Browser ရဲ့ Rendering Engineကနေပီးမှ User မြင်နေရတဲ့ user interfaceအနေနဲ့ ပြန်ပြောင်းပေးတာဖြစ်တယ် 

Browser 1ခုမှာဆို 
Rendering Engine => HTML, CSS(like webkit, blink)
JS Engine => Like V8 in chrome
ဆိုပီး ၂ပိုင်းပါတယ် JS engine က သုံးတဲ့ Browserပေါ်မူတည်ပီး ကွဲပြားတယ် 

အဲ့လိုမျိုး rendering engine and JS engineမတူတဲ့တွက် cross browser issueတွေ့ ရနို်ငတယ် ကုဒ်က ဒီ browser မှာ အဆင်ပြေပီး နောက် browserမှာမလုပ်တာမျိုး ကြုံတွေ့နို်ငတယ် 

How Browser and reuest response work

use Browser 
	http request => web server
	http response <= web server

In http response = HTML CSS + JS
 	HTML CSS => work from Rendering Engine
        JS => work from JS Engine

Compiler ဆိုတာက source code ကိုယူပီး machine code(computer နားလည်တဲ့ ကုဒ်)နေနဲ့ ပြောင်းပေးတာကို ခေါ်တယ် တိုက်ရိုက်ပြောင်းပေးတဲ့ ကောင်တွေက C, C++, Goတို့လိုကောင်မျိုးတွေဖြစ်တယ် ဘာကောင်းလဲဆိုရင် machine direct နားလည်တဲ့ကောင်ဖြစ်တဲ့တွက်ကြောင့် process executing time မြန်တယ် ဒါပေမဲ့ platform dependent ဖြစ်တယ် အဲ့နေရာမှာ platform ဆိုတာဘာကိုဆိုလိုလဲဆို runနေတဲ့ OS(operating system) like window, mac, linuxနဲ့ လုပ်ဆောင်နေတဲ့ CPUပေါ်မူတည်နေတာကိုပြောတာ အဲ့တော့ ဘာဖြစ်လဲဆိုရင် window မှာ runထားတဲ့ကောင်ကို Linux မှာ runမရဘူး

အဲ့တော့ compilerပေမဲ့ platform independent မဖြစ်တဲ့ကောင်နေနဲ့ဆိုရင် ဘာရှိလဲဆို Java, C#တို့လိုကောင်မျိုးရှိတယ် သူတို့ကကျ ဘယ်လိုလုပ်လဲဆို Javaမှာဆိုရင်ကျ source codeကို ယူပီး byte codeထုတ်လို်က်တယ် အဲ့byte codeကိုမှ JVM(java virtual machine)နေပီး native code(computer နားလည်တဲ့ ကုဒ်)နေနဲ့ ပြောင်းပေးတာဖြစ်တဲ့တွက် platform independent ဖြစ်သွားတယ် ဒါပေမဲ့ processing timeမှာတော့ C, Goတို့လောက်တော့ မြန်မှာ မဟုတ်ဘူး

နော်ကတခုကကျတော့ interpreter သူကကျတော့ native code နေနဲ့ မထုတ်ပဲ on the fly (run နေတဲ့ ချိန်မှာမှ)လုပ်ဆောင်ပေးသွားတာဖြစ်တယ် အဲ့ကြောင့် သူက အခြားကောင်တွေထက်စာရင် ပိုနှေးတယ် ဒါပေမဲ့ ဘာနေနဲ့ သုံးရလဲဆို dynamic type language တွေမှာ လုပ်ဆောင်လို့ရတယ် 

1. static type - varible ၁ခုသည် typeတခုပဲရှိတယ် သူ့ကို type 1ခုသတ်မှတ်ပီးအခြားတခု ထည့်လို့ရနေတာမျိုးကို ပြောတယ်
   good point - type checking ကို compile time levelမှာတင်သိနိုင်တယ်။
   eg. programming language Java, C#, typescript,

2. dynamic type - varible ၁ခုသည် typeတခုမကပဲ မျိုးမျိုးပြောင်းလဲ ထည့်လို့ရနေတာမျိုးကို ပြောတယ်
   good point နေနဲ့က type flexible ဖြစ်တယ်
   bad points နေနဲ့က type errorတွေကို မသိနိုင်ဘူး
   eg. programming language javascript, python

3. weakly type - ဆိုတာက invalid operationတွေကို ပေးလုပ်တဲ့ languageမျိုးကိုခေါတယ် 
   dynamic typeဖြစ်တိုင်း weakly typeမဖြစ်ဘူး invalid operationတွေကို ပေးလုပ်မှ weakly typeလို့ခေါတယ်
   eg. programming language javascript, php

4. strongly type - ဆိုတာက invalid operationတွေကို ပေးမလုပ်ဘူး type error cacheလုပ်နိုင်တယ်
   ဒါပေမဲ့ ဘယ်လောက် stronglyဖြစ်တယ်ဆိုတာ languageပေါ မူတဉ်တယ် 
   ဥပမာ C++ and java နဲ့မှာဆို java က ပိုပီး stronglyဖြစ်တယ်လို့ပြောလိုရတယ်
   eg. programming language javascript, python

5. hybrid type - static and dynamic type featureတွေရောပီး ထည့်ထားတဲ့ကောင်မျိုးကိုခေါတယ်
   eg. programming language C#(dynamic for dynamic type system )

6- sub typing - sub typingဆိုတာက super typeထဲကို super typeသော် လည်းကောင်း super typeကို base ခံထားတဲ့
                child type သော်လည်းကောင်းထည့်လိုရတယ် သူနဲ့ မဆက်ဆက်နေတဲ့ကောင်တွေထည့်လို မရဘူး
                အဲ့တာမျိုးကိုခေါ်တယ် 

7. duck typing - ဆိုတာကကျတော့ သူသည် parent child relationshipရှိစရာမလိုဘူး သူ့မှာ relationship ရှိမရှိကို ဂရုမစိုက်ဘူး
                 သူသုံးချင်တဲ့ကောင်အဲ့မှာရှိလား ရှိရင်ခေါ်လိုက်မယ် အဲ့လိုမျိုးကိုခေါ်တယ်
                 duck typingက dynamic type programming languageတွေမှာပဲ ရှိတယ်

8. nominal typing - ဆိုတာက class 2ခု သည် structure တူတယ် ဒါပေမဲ့ တခုကနေတခုကို assign လုပ်ခွင့်မပေးဘူး
                    အဲ့တာမျိုးကို nominal typing ခေါ်တယ် structure တူပေမဲ့ type equal မတူတဲ့ကောင်မျိုးကိုခေါ်တယ် 
                    eg. programming language Java

9. structural typing - ဆိုတာက class 2ခု သည် structure တူတယ် ပီးတော့ တခုကနေတခုကို assign လုပ်ခွင့်ပေးတဲ့ကောင်မျိုးကို
                    structural typing ခေါ်တယ် type equality တူစရာမလိုဘူး structureတူရင် ရပီ
                    eg. programming language javascript, typescript

type hints - ဆိုတာက dynamic type system တွေမှာ type error တွေကို ပြဖို့ရာတွက် enhanced လုပ်ထားတဲ့ကောင်မျိုးကိုခေါတယ်


variable ဆိုတာ နောက်တချိန်မှာ ပြန်သုံးမယ့် တန်ဖိုးတခုခု number,string, boolean လိုမျိုး တန်ဖိုးတခုခုကို memory addressပေါ်မှာ နေရာ ယူထားတဲ့ကောင်မျိုးဖြစ်တယ် 
Eg. let a = 20;

a ဆိုတာက variable name, 20 ဆိုတာက variable တန်ဖိုး ကြေညာမယ်ဆို 
အထက်က syntax လို မျိုး မှန်ရမယ် 
အဲ့တာကိုမှ ခုက ကိန်းဂဏန်းတန်ဖိုးရှိနေတာကို အခြား တန်ဖိုးပြောင်းလဲ ထည့်လို့ရတယ်
Eg. let a = 20;
a = 'hello';
a = true;

အဲ့လိုမျိုး variable တခုထဲကိုမှ တန်ဖိုးပြောင်းလဲထည့်ရတာကို dynamic type language လို့ခေါ်တယ် language နေနဲ့ဆို Javascript, python, PHPတို့လိုကောင်မျိုးရှိတယ်

နောက်တခုကကျတော့ static type language သူကကျ ဘဘ်လိုလဲဆို type တခုကို ကြေညာပီးသွားရင် အခြားတစ်ခု ပြောင်းလဲထည့်လို့မရတာမျိုးကိုခေါ်တဘ် language နေနဲ့ဆို Java, C#တို့လိုကောင်မျိုးဖြစ်တယ် ဥပမာနေနဲ့ဆို
int a = 10;
a = false; // Error can't assign

Scripting Languageဆိုတာ သူကြည့်ပဲ နေလို့မရပြ အခြားတခုပေါ်မှာ မှီပီးနေရတာမျိုးကိုခေါ်တဘ် ဥပမာဆို JSလိုကောင်မျိုးပေါ့ သူဆို browserပေါ်မှာ ကပ်တွယ်နေရတာဖြစ်တယ် 

Syntax - ဆိုတာ ရေးထုံးကိုခေါ်တယ် ဥပမာ variable ဘယ်လိုကြေညာလဲဆိုတာမျိုး
Semantic - ဆိုတာက လုပ်ဆောင်ချက်ကို ပြောတာ ရေးထုံးတူပေမဲ့ ‌ေနာက်ကွယ်က လုပ်ဆောင်ချက်တွေက မတူနို်ငဘူး ဥပမာဆို Javaမှာဆို 3/2က 1ရပေမဲ့ Javascriptမှာဆို 1.5ရတယ် အဲ့လိုမျိုး internal workingမတူတာမျိုးကိုခေါ်တဘ် 
Pragmatic - ဆိုတာက ပိုပီး လက်တွေ့ကျတာကိုခေါ်တဘ် language ပေးထားတဲ့ကောင်တွေကို သူံနေရာနဲ့သူ မှန်မှန်ကန်ကန် အသုံးချတက်တာမျိုးကိုခေါ်တဘ်  အဖြေရတာချင်းတူပေမဲ့ efficient ဖြစ်ဖြစ် ပိုကောင်းတဲ့ကောင်မျိုး ဘယ်လိုရေးမလဲဆိုတာမျိုးကိုခေါ်တဘ် 

Lexical Strcutureဆိုတာက ရေးလိုက်တဲ့ syntaxတွေကို တခုချင်းပြန်ဖြတ်ပီး programming languageရဲ့ အောက်ဆုံးကနေပီး Grammar ruleတွေ မှန်မှန် ပြန်စစ်တာမျိုးကို ခေါ်တဘ် 

Commentsဆိုတာက ဘာလုပ်တာလဲဆိုတာသိအောင် မှတ်ထားတဲ့ကောင်မျိုးကိုခေါ်တဘ် Javascript မှာဆို 
// for single line coment, /* */ for multiline comment ဆိုပီး ရှိတယ် 
အဲ့ကောင်တွေက program runတဲ့ချိန်မှာဆိုရင်တော့ ထည့်ပီး လုပ်ဆောင်သွားမှာ မဟုတ်ဘူး 

-------------------------------------

Literal ဆိုတာက immediate value ထည့်လိုက်တာမျိးကိုပြောတာ
Eg. 
23 		number lateral
'Hello'	string lateral
 true	boolean lateral
 1.2		number lateral

identifierဆိုတာ နာမည်ပေးလို့ရတာမျိုးကိုခေါ်တဘ် 
Eg variable name, function name တို့လိုကောင်မျိုးကိုခေါ်တဘ် သူ့မှာလဲနာမည်ပေးမယ်ဆို ruleတွေရှိတယ် _,letter, $နဲ့စလို့ရတယ် အဲ့လိုမဟုတ်ဘူးဆို syntax error တက်မယ် နောက်ကကောင်တွေကျ letter, digit, underscore, dollar sign လိုက်လိုရတယ်
identifierတွေက case sensitiveဖြစ်တယ် ပြောရမယ်ဆို let a = 20; let A = 30; ကမတူဘူး
ပီးရင် reserve wordတွေ မပေးရဘူး RESERVE WORDSဆိုတာက ဒီlangague ကနေပီး သုံးမယ် သတ်မှတ်ထားတဲ့ နာမည်တွေသုံးမရဘူး ဘယ်လိုကောင်မျိုးလဲဆို let, if, while, functionတို့လိုကောင်မျိုး ကိုခေါ်တာ 

Unicode ဆိုတာ english စာမဟုတ်တဲ့ အခြား ဘာသာစကား language စာလုံးတွေကို ပြောတာ
Javascript မှာက semicolon က optional ဖြစ်တယ်ပါလဲရတယ် မပါလဲရတယ် ဒါပေမဲ့ ဖြစ်နိုင်ရင်တော့ ထည့်တာကောင်းတဘ်

variableဆိုတာ ထပ်ကာထပ်ကာ အသုံးပြုမဲ့ကောင်တန်ဖိုးတွေကို အဲ့လိုမျိုးသုံးရင် နောင်ကျ ပြင်ဖို့မလွယ်တဲ့ ပြသနာတွေကို ဖြေရှင်းဖို့ တန်ဖိုး(value)တွေ သိမ်းထားတဲ့ကောင်ဖြစ်တယ် 
value ဆိုတာက lateral တွေဖြစ်တယ် 

Type ဆိုတာက ဘာလဲဆိုရင် valueတွေရဲ့ အမျိုးအစားဖြစ်တယ် type ကိုစစ်ချင်ရင် typeof variable nameဆိုပီး စစ်လို့ရတယ် 
eg. let a = 10;
console.log('type of a ' , typeof a);
Type က 1. set of possible values, 2.determine operation အဲ့ ၂ချက်ကို ဆုံးဖြတ်တယ် 
ဥပမာနေနဲ့ဆို 
let a = 10;
a = a + 5; // number + number(make number addition)
console.log('value of a ', a); // 15

a = '10';
a = a + 5; // string + number(make string concatenation)
console.log('value of a ', a); // 15

dynamic type language တွေမှာ type သည် value ပေါ်မှာ မူတည်တယ်
static type langague တွေမှာကျ type သည် varaible and typeပေါ်မူတည်တယ် 

အဲ့ကျ variable, type and value ဘဘ်လိုဆက်ဆက်နေလဲဆို 
variable => value store 
value  => define type
type => 1. set of possible value 2. determine operation

Typeမှာဆို primitive, object typeဆိုပီး ၂ခုပါတယ်
primitive typeဆိုတာ ထပ်ခွဲလို့မရတဲ့ typeမျိုးကိုခေါ်တာ ဘာတွေပါလဲဆိုရင်
number, boolean, string, null, undefined, symbolဆိုပီးပါတယ်
primitive typeမဟုတ်တဲ့ကောင်တွေကို object type လို့ခေါ်တယ် 

Number ထဲမှာ ဘာပါလဲဆို ကိန်းပြည့်(integral type), ဒသမကိန်း (floating point)တွေပါတယ် Number Type ကြေညာချင်တယ်ဆိုရင်
let a = 5; 
a = 3.2;
a = 0xff; //hexa lateral from 0 to 9, a to f (color code, image processing)တွေမှာ သုံး
‌a = 0b11; // binary(only 0 and 1)
a = 1_000_000; // readableဖြစ်အောင် underscore ထည့်ရေးရ

Arithematic တွေနနဲ့ဆို +,-,*,/,%တွေပါတဘ် အခြားကောင်တွေသုံးချင်ရင် Mathထဲကပါတယ် build in function တေွသု့းလို့ရတယ် ဥပမာ 2နှစ်ထပ်လိုချင်ရင် Math.pow(2,2)ဆိုပီး သုံးနိုင်တယ် 
 0.3 - 0.2ကိုနုတ်ရင် 0.1မ၇ဘူး အဲ့တာဘာလို့လဲဆိုရင် computer limitationကြောင့်ဖြစ်တယ် အဲ့တာဘာလိုလဲဆို PIလို irrational numberတွေကို store လုပ်ရင် approximatelyသိမ်းတဲ့ အကျိုးဆက်နေနဲ့ float valueတေါကို သိမ်းတဲ့နေရာမှာပါ effectဖြစ်တာဖြစ်တယ် 
number တန်ဖိုးတခုကို 0နဲ့စားရင် infinity ရတယ် 
0ကို 0နဲ့စားရင် number 1ခုကို invalid operation လာလုပ်ရင် NaN(Not a Number)ရတဘ်
NaNက NaNနဲ့ တူလားဆိုလဲ မတူဘူးပဲရမယ် ဘာလို့ဆိုတော့ NaNရနိုင်တဲ့ အကြောင်းရင်းများစွာရှိလို့ဖြစ်တယ် 
 a = 0;
      b = 12 / a;
      console.log("B ", b);
      b = 0 / 0;
      console.log("B ", b);
      b = a * "hello";
      console.log("B ", b);
      b++;
      console.log("B ", b);
      console.log("B ", b == b);

number 1ခုက NaNလားစစ်ချင်ရင် isNaNနဲ့စစ်ရတယ် Eg. isNaN(b)
1/0 ဆို positive infinity
-1/0 ဆို negative infinity
0မှာ positive 0 (0), negative 0(-0)ဆိုပီးရှိ 
ဘယ်နေရာမှာကွာလဲဆို infinityထုတ်တဲ့နေရာမှာရှိ 
ဒါပေမဲ့ positive and negative 0တူလားဆိုတူတယ်
ဘာလို့ အဲ့တာတွေကွာလဲဆို number တွေကို represent လုပ်ရင် ရှေံဆုံး 1bitစာကို 
sign bit နဲ့ representလုပ်လို့ဖြစ်တယ်

power ကို double asteriskနဲ့လဲရေးလို့ရတယ်
Math.pow(2, 3) or 2**3;

အရမ်းများတဲ့ ကိန်းဂဏန်းတန်ဖိုးကို သိမ်းချင်ရင် BigIntကိုသုံးနိုင်တယ်
ဒါပေမဲ့ အားနည်းချက်နေနဲ့ slow ဖြစ်စေတယ်
--------------------------------------

Text or String ဆိုတာ character တွေများကြီးစုထားတဲ့ကောင်ကိုခေါ်တယ်
string ၁ခုကြေညာမယ်ဆို string lateral 3ခုနဲ့ ကြေညာရတယ်။
single quote, double quote, backtickကြိုက်တာနဲ့ ကြေညာရတယ်
Eg. let str = 'hello';
str = "Hello";
str = `Hello`;
double quoteထဲမှာ double quote,single quotထဲမှာesingle quoteထည့်ချင်ရင်
escapeလုပ်ပစ်ရမယ်
Eg. str = "Hello \"I'm good"";

string 2ခုချိတ်ဆက်ချင်ရင် + ကိုသုံးနိုင်တယ်
      eg.
        let quantity = 2;
        let price =  200;
        let str1 = 'Price ' + price + 'Quantity'+ quantity + 'Total ' + (price * quantity);
        console.log('Str1 ', str1);

multiline သုံးချင်ရင် backtickကိုသုံးနိုင်တယ်
        str1 = `Price ${price}
        Qty ${quantity}
        total ${price * quantity}`;
        console.log('Str1 ', str1);

backtickuကို template tag function အနေနဲ့သုံးနိုင်တယ် ဘယ်လိုလုပ်လဲဆို 
fuction name + backtick ဆိုတဲ့ပုံစံနဲ့သွားတယ် 
အပေါ်က string.raw()ဆိုတဲ့ function ကို လုပ်ဆောင်တဲ့အခါမှာ parameter အနေနဲ့ backtick
ထဲကောင်ကို ထည့်ေပးပီး လုပ်ဆောင်သွားတာဖြစ်တယ် 
string.raw({raw: `Hello\nWorld`})ဆိုတာမျိုး ရေးစရာမလိုပဲ
string.raw`Hello\nWorld` ဆိုပီးရေးလို့ရတယ် ရမယ့် ရလဒ်ကတော့ အတူတူပဲဖြစ်တယ်

နောက်ထပ်ဥပမာ တခုအနေနဲ့ဆိုရင် အောက် function ကိုခေါ်တဲ့ အခါမှာ ပုံမှန်ခေါ်နေကြပုံစံအစား
backtickကိုသုံးနိုင်တယ်
function stringConcat(name){
   return `Hello ${name}`;
}

console.log(stringConcat('John'));
console.log(stringConcat`John`);

multiple argument တွက်ဆို ေအာက်ကလို သုံးနိုင်တယ်
function sum(strings, a, b){
   return `Sum of ${a} and ${b} is ${a + b}`;
}
console.log(sum`${1}${2}`);

strings က ဘာကိုဆိုလိုတာလဲဆို ေပးလိုက်တဲ့ စာကြောင်းက template lateral နဲ့မဟုတ်တဲ့ အခြား တန်ဖိုးတေွကို ယူဖို့ဖြစ်တယ်
ဥပမာဆိုရင်  အောက်ကောင်ကို ထပ်ကြည့်ပါ
const person = "Mike";
const age = 28;

function myTag(strings, personExp, ageExp) {
  const str0 = strings[0]; // "That "
  const str1 = strings[1]; // " is a "
  const str2 = strings[2]; // "."

  const ageStr = ageExp < 100 ? "youngster" : "centenarian";

  // We can even return a string built using a template literal
  return `${str0}${personExp}${str1}${ageStr}${str2}`;
}

const output = myTag`That ${person} is a ${age}.`;

console.log(output);
// That Mike is a youngster.
 ေပးလိုကတဲ့ string က That, is a, .ဆိုတဲ့ေကာင်တေွက stringsထဲကိုရောက်သွားပီး အဲဲ့ကောင်ကို 
 ပြန်လည်သုံးချင်ရင် အသုံးပြုလို့ရပါတယ် multiple argumentတွက်ဆို strings ေနရာမှာရှိတဲ့ေကာင်က
 မထည့်လို့မရပါဘူး

 -----------------------------------
 boolean ဆိုတာကလဲ primitive data type အမျိုးစားဖြစ်တယ်
 သူ့မှာ value အနေနဲ့ true, falseဆိုပီး နှစ်မျိုးရှိတယ် 
 သူ့ကို ဘယ်နေရာတေွမှာ သုံးလဲဆိုရင် လုပ်မလားမလုပ်ဘူးလားဆိုတဲ့ condition တေွစစ်တဲ့အခါမှာ သုံးတာများတယ်
 ဥပမာေနနဲ့ဆိုေအာက်က ဥပမာကိုကြည့်ပါ
 let raining = false;
console.log('Type of raining ', typeof raining);
if(raining){
   console.log('Take umbrella');
}else{
   console.log('Take Hat');
}

javascript boolean က အခြားlanguage ေတွနဲ့ မတူဘူး condition မှာ boolean ဖြစ်နိုင်တဲ့ တန်ဖိုးက
true, false တင်မကပဲ အခြားတန်ဖိုးေတွလဲ ဖြစ်နိုင်တယ်
အဲ့တော့ အဲ့တန်ဖိုးကို ဘယ်လိုခွဲခြားမလဲဆို ပုံမှန် true, falseမဟုတ်ပဲ 
truthy falsyဆိုပီး ခွဲခြားမှတ်သားနိုင်တယ် truthy ဖြစ်နိုင်တဲ့ အခြေနေက များစွာရှိတဲ့တွက်ကြောင့်
falsy ကိုမှတ်ထားရင် ကျန်တာက truthy ဆိုပီး ခွဲခြားနိုင်တယ်
falsy ဖြစ်တဲ့ ေကာင်တေွကတော့ 

undefined, null, NaN, 0, -0, false, ""
တို့ပဲဖြစ်တယ် အဲ့တန်ဖိုးကလွဲ အခြား တန််ဖိုးတေွက truthyတန်ဖိုးတေွဖြစ်ကြတယ် 
မြင်အောင်ဥပမာေပြာရမယ်ဆို
အပေါ်က ဥပမာကိုပဲ အောက်ကလိုေရးနိုင်တယ်
if(1){
   console.log('Truthy value');
}

if({name: 'John'}){
   console.log('truthy value');
}

if('mgmg'){
   console.log('truthy value');
}

----------------
null & undefined
null ကော undefinedကောက တန်ဖိုးမရှိဘူးဆိုတာကို  ပြောတာ
ဒါပေမဲ့ ဘာကွာလဲဆိုရင် 
undefined ကကျတော့ variable တခုကို ေကြညာထားတယ် ဒါပေမဲ့ တန်ဖိုးသတ်မှတ်ထားတာမရှိတာမျိုး
objectကနေ မရှိတဲ့ propertiesကို ယူတဲ့အခါမျိုး string ကနေ မရှိတဲ့ index valueကိုထုတ်တဲ့ အခါမျိုးတေွမှာ undefined
တန်ဖိုးကိုရမယ်
nullကကျတော့ တန်ဖိုးတခုကို သေသေချာချာ null valueထည့်တဲ့ အခါမျိုးမှာ nullအနေနဲ့ ရမယ်

နောက်ကွာခြားချက်တခုကကျတော့ data type 
undefinedရဲ့ data type ကကျတော့ undefined ဖြစ်ပီး
nullရဲ့ data type ကကျတော့ objectဖြစ်တယ်

ဥပမာအနေနဲ့ဆို အောက်ပါတိုင်းဖြစ်တယ်။
let obj = {};
console.log('Obj ', obj.age); // undefined

let data;
console.log('data', data); // undefined;

let str = 'Hello';
console.log('Str [10]', str[10]); // undefined;
console.log('Type of data ', typeof data); // undefined;

data = null;
console.log('Data ', data); // null
console.log('Type of data', typeof data); // object

အဲ့တာမို့ ရိုးရိုး value equality နဲ့ စစ်မယ်ဆို true ရပီး
reference equality နဲ့ စစ်မယ်ဆို falseတန်ဖိုးကိုရမယ်
ေပြာချင်တာက ဒိလိုဖြစ်တယ်။
undefined == null; // true
undefined === null; // false

---------------------------
Global Object
Global Objectဆိုတာက window ဆိုတဲ့ထဲမှာရှိတဲ့ကောင်တေွကို ပြောတာဖြစ်တယ်
window မှာရှိတဲ့ကောင်တွေကိုခေါ်ချင်ရင် window.ဆိုတာမသုံးပဲနဲ့လဲခေါ်နိုင်တယ်။
ဥပမာအနေနဲ့ဆိုရင် isNaNလားစစ်ချင်ရင်
window.isNaN(10); // false
isNaN(10); // false
နဲ့ အတူတူပဲဖြစ်တယ်။

-----------------------
Immutable Primitive values and Mutable Object Values
immutable ဆိုတာက variable မှာရှိတဲ့တန်ဖိုးကို အခြားvariable တွေထဲမှာ ထည့်ထားပီး 
အဲ့တန်ဖိုးကို ပြင်လိုက်ရင် သူ့တန်ဖိုးကို သုံးထားတဲ့ အခြားvariableတွေမှာ တန်ဖိုးမပြောင်းလဲသွားတာကို ပြောတာဖြစ်တယ်
immutable ကို primitive type တွေဖြစ်တဲ့ number, boolean, string, undefined, null, symboleတို့မှာတွေ့ရမှာဖြစ်တယ်

mutableကတော့ သူနဲ့ပြောင်းပြန်ဖြစ်တယ် မှာရှိတဲ့တန်ဖိုးကို အခြားvariable တွေထဲမှာ ထည့်ထားပီး 
အဲ့တန်ဖိုးကို ပြင်လိုက်ရင် သူ့တန်ဖိုးကို သုံးထားတဲ့ အခြားvariableတွေမှာပါ တန်ဖိုးပြောင်းလဲသွားတာကို ပြောတာဖြစ်တယ်
mutableကိုတော့ object data typeတွေမှာ တွေ့ရမှာဖြစ်တယ်

ဥပမာအနေနဲ့ဆိုရင် အောက်ကကောင်ကိုကြည့်ရအောင်
let a = 10;
let b = a;
console.log('a ', a, 'b ', b); // a 10 b 10
a = 20;
console.log('a ', a, 'b ', b); // a 20 b 10

let obj ={
   name : 'HWH',
   age : 21
};
let obj1 = obj;
console.log('Obj ', obj, 'Obj1 ', obj1); // obj name = HWH, age =21, obj1 name = HWH, age =21   
obj.name = 'HWH2';
console.log('Obj ', obj, 'Obj1 ', obj1); // obj name = HWH2, age =21, obj1 name = HWH2, age =21  

အပေါ်ကတခုမှာဆို a ရဲတန်ဖိုး 10ရှိနေတာကို bထဲထည့်လိုက်တယ် ပီးနောက်မှာတော့ a ရဲ့တန်ဖိုးကို 20 လို့ပြန်ပြီးထည့်ပီး
တန်ဖိုးထုတ်ကြည့်တဲ့အခါ a ရဲ့တန်ဖိုးက 20ဖြစ်သွားပီး b ရဲ့တန်ဖိုးကတော့ 10 ပဲရှိနေတာကိုတွေ့ရမှာဖြစ်တယ်
ဒါကဘာလို့ဆိုရင် primitive data typeရဲ့ immutable data structure ကြောင့်ဖြစ်တယ်
ထပ်ရှင်းရမယ်ဆို primitive type တွေက variable 1 ခုနေအခြားတခုကို ထည့်တည့်အခါမှာ value ကိုပဲ သွားထည့်တာဖြစ်တယ်
value copy လို့နောက်တမျိုးပြောနိုင်ပါသေးတယ်

ဒါပေမဲ့ ဒုတိယဥပမာမှာ objတန်ဖိုးကို obj1 ထဲကို ထည့်ထားပါတယ်
အဲ့နောက်မှာ objရဲ့name ဆိုတဲ့ property ကို HWH2ဆိုပီးပြောင်းလိုက်တယ်
ဒါပေမဲ့ အဲ့တန်ဖိုးက obj1ရဲ့ nameမှာပါပြောင်းလဲသွားတာကို တွေ့ရမှာ ဒါက ဘာလို့လဲဆို objectမှာရှိတဲ့
mutatble data structureကြောင့်ဖြစ်တယ်
အသေးစိတ်ရှင်းရမယ်ဆို objဆိုတဲ့ object ကို ဆောက်လိုက်လိုက်တဲ့အချိန်မှာ computer memoryမှာ 
ဥပမာအနေနဲ့ 0x12 ဆိုတဲ့ နေရာလေးနဲ့ memory address သွားယူတယ်
အဲ့အချိန်မှာ obj တန်ဖိုးကို obj1ထဲကို ထည့်လိုက်တယ် ဒါပေမဲ့ သူကကျတော့ တန်ဖိုးပဲ ကော်ပီယူသွားတာမဟုတ်ပဲ
ခုဏက memory addressကို သွားကူးသွားတာဖြစ်တယ် 
ဒါ့ကြောင့်မို့ objကော obj1ကောက 0x12 ဆိုတဲ့ memory addressကို သွားပီးထောက်နေပီးမှ အဲ့memory addressမှာရှိနေတဲ့ 
name, ageဆိုတဲ့ တန်ဖိုးကို သွားယူတာဖြစ်တယ်
ဒါကြောင့်မို့ objကနေပီး nameဆိုတဲ့ တန်ဖိုးပြောင်းလိုက်တယ်ဆိုတာက 0x12 ဆိုတဲ့ memory addressမှာရှိတဲ့ name ဆိုတဲ့ တန်ဖိုးကို
ပြောင်းလဲလိုက်တာဖြစ်တဲ့တွက်ကြောင့် obj1ရဲ့ nameတန်ဖိုးကိုပါ ပြောင်းလဲသွားတာဖြစ်တယ်။
object မှာ copy ကူးတာကကျတော့ reference semantic ကိုသုံးသွားတာဖြစ်တယ်။

ဒါပေမဲ့ obj ကိုပဲ အောက်က ဥပမာကိုဆက်ကြည့်ရအောင်

obj1 = {
   name : 'mgmg',
   age : 18
};
console.log('Obj ', obj, 'Obj1 ', obj1); // obj name = HWH2, age =21, obj1 name = mg mg, age = 18

ဒီကောင်မှာဆိုရင်ကျ obj1 ကိုနောက်ထပ် object အသစ်တန်ဖိုးထည့်လိုက်တယ်
ပီးပြန်ပီးတန်ဖိုးတွေထုတ်ကြည့်တဲ့အချိန်မှာကျတော့ obj နဲ့ obj1 တန်ဖိုးမတူနေတာကိုတွေ့ရမယ် 
ဒါကဘာလို့လဲဆိုရင် obj1ရဲ့ တန်ဖိုးကို ချိန်းတာမဟုတ်ပဲ နောက်ထပ်objectအသစ်တခု ဆောက်လိုက်တာကြောင့်ဖြစ်တယ်
ပြောရမယ်ဆို အစက objနဲ့ obj1 က memory address 0x12ကို အတူတူကြည့်နေရာကနေ obj1 ကိုနောက်ထပ် object အသစ်ထည့်လိုက်တဲ့အတွက်ကြောင့်
obj1 က ဥပမာအနေနဲ့ memory address 0x13ဆိုတဲ့ အသစ်ကိုသွားပြောင်းထည့်လိုက်လို့ဖြစ်တယ်
ဒါ့ကြောင့် ဒိချိန်မှာ obj က 0x12, obj1 က 0x13မှာရှိတဲ့ တန်ဖိုးအသီးသီးကို ယူထားပီး အလုပ်လုပ်နေကြလို့ဖြစ်တယ်
ဒါကတော့ object mutable data structure ရဲ့ နောက်ထပ်သိထားသင့်တဲ့ အကြောင်းရာတခုဖြစ်တယ်။

------------------------
Type Conversion
- ဆိုတာက ရှိနေတဲ့ data type တခုကနေ အခြားတခုကို ပြောင်းလဲတာမျိုးကို ပြောတာဖြစ်တယ်။
အဲ့တော့ data type တခုကနေ အခြားတခုပြောင်းရင် JS မှာ ဘယ်လိုပြောင်းလို့ရလဲ ဘယ်လိုတန်ဖိုးတွေကို ပြောင်းလဲသွားလဲ ဆက်ကြည့်ကြရအောင်

type ၁ခုကနေ number typeကိုပြောင်းမယ်ဆိုရင် parseInt(value)လို့ပြောင်းလို့ရသလို +valueဆိုပီးလဲပြောင်းလို့ရတယ်
အဲ့တော့ အခြားtype တခုကနေ number typeကိုပြောင်းမယ်ဆို အောက်ကလိုပုံစံမျိုးပြောင်းလဲမှာဖြစ်တယ်။

undefinde to number ကိုပြောင်းမယ်ဆို NaNရမယ် eg. +undefined; // NaN
null to number ကိုပြောင်းမယ်ဆို 0ရမယ် eg. +null; // 0
boolean true to number ကိုပြောင်းမယ်ဆို 1ရမယ် eg. +true; // 1
boolean false to number ကိုပြောင်းမယ်ဆို 0ရမယ် eg. +false; // 0
empty string to number ကိုပြောင်းမယ်ဆို 0ရမယ် eg. +''; // 0
nonempty numeric string to number ကိုပြောင်းမယ်ဆို numeric valueရမယ် eg. +'10'; // 10
noempty non-numeric string to number ကိုပြောင်းမယ်ဆို NaNရမယ် eg. +'abc'; // NaN

type ၁ခုကနေ string typeကိုပြောင်းမယ်ဆိုရင် value.toString()လို့ပြောင်းလို့ရသလို value + ''ဆိုပီးလဲပြောင်းလို့ရတယ်
အဲ့တော့ အခြားtype တခုကနေ string typeကိုပြောင်းမယ်ဆို အောက်ကလိုပုံစံမျိုး ပြောင်းလဲမှာဖြစ်တယ်

undefined to string ကိုပြောင်းမယ်ဆို 'undefined'ရမယ် eg. '' + undefined; // undefined
null to string ကိုပြောင်းမယ်ဆို 'null'ရမယ် eg. '' + null; // null
boolean true to string ကိုပြောင်းမယ်ဆို 'true'ရမယ် eg. '' + true; // true
boolean false to string ကိုပြောင်းမယ်ဆို 'false'ရမယ် eg. '' + false; // false
number 0 to string ကိုပြောင်းမယ်ဆို '0'ရမယ် eg. '' + 0; // '0'
Infinity to string ကိုပြောင်းမယ်ဆို 'Infinity'ရမယ် eg. '' + Infinity; // Infinity
-Infinity to string ကိုပြောင်းမယ်ဆို '-Infinity'ရမယ် eg. '' + -Infinity; // -Infinity
NaN to string ကိုပြောင်းမယ်ဆို 'NaN'ရမယ် eg. '' + NaN; // NaN

type ၁ခုကနေ boolean typeကိုပြောင်းမယ်ဆိုရင်!!valueလို့ပြောင်းလို့ရသလို Boolean(value)ဆိုပီးတော့လဲ ပြောင်းလို့ရတယ်
အဲ့တော့ အခြားtype တခုကနေ boolean typeကိုပြောင်းမယ်ဆို အောက်ကလိုပုံစံ မျိုးပြောင်းလဲမှာဖြစ်တယ်
undefined to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!undefined; // false
null to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!null; // false
empty string to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!''; // false
nonempty numeric string to boolean ကိုပြောင်းမယ်ဆို trueရမယ် eg.!!'10'; // true
noempty non-numeric string to boolean ကိုပြောင်းမယ်ဆို trueရမယ် eg.!!'abc'; // true
NaN to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!NaN; // false
number 0 to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!0; // false
number -0 to boolean ကိုပြောင်းမယ်ဆို falseရမယ် eg.!!-0; // false
number 1 to boolean ကိုပြောင်းမယ်ဆို trueရမယ် eg.!!1; // true
-Infinity to boolean ကိုပြောင်းမယ်ဆို trueရမယ် eg.!!-Infinity; // true
Infinity to boolean ကိုပြောင်းမယ်ဆို trueရမယ် eg.!!Infinity; // true

objectတန်ဖိုးကနေ number typeကိုပြောင်းမယ်ဆိုရင် ဘယ်လိုလုပ်လဲဆိုရင် အဲ့ object မှာ valueOfဆိုတဲ့ function ကနေပြန်တဲ့တန်ဖိုးရှိလားကြည့်မယ်
ရှိရင် အဲ့ကပြန်တဲ့တန်ဖိုးကို ပြန်ကြည့်ပီးမှ အပေါ်က nubmer typeကိုပြောင်းတဲ့ပုံစံတိုင်းပြန်လုပ်မယ်
ဟုတ်ပီ အဲ့တော့ valueOfဆိုတဲ့ function မရှိဘူးဆို toStringဆိုတဲ့ function ကနေပြန်တဲ့တန်ဖိုးရှိလား ထပ်ကြည့်မယ်
ရှိရင် အဲ့ကပြန်တဲ့တန်ဖိုးကို ပြန်ကြည့်ပီးမှ အပေါ်က number typeကိုပြောင်းတဲ့ပုံစံတိုင်းပြန်လုပ်မယ်
ဟုတ်ပီ အဲ့တော့ toStringဆိုတဲ့ function ကော valueOfဆိုတဲ့ function ကောရှိရင်ကျတော့ valueOfက ပြန်တဲ့ တန်ဖိုးကိုကြည့်ပီး အလုပ်လုပ်မှာ ဖြစ်တယ်။
တခုဖြစ်ရမှာက အဲ့functionတွေကနေပြန်တဲ့ တန်ဖိုးတွေက primitive type ဖြစ်နေဖို့လိုတယ် 
valueOfကနေ ပြန်တဲ့ကောင်က object ဖြစ်ပီး toStringကနေပြန်တဲ့ တန်ဖိုးက primitive type ဆိုရင်တော့
toStringကနေ ပြန်တဲ့တန်ဖိုးကိုယူပီး ဆက်လက်လုပ်ဆောင်သွားမှာဖြစ်တယ်။
primitive type မဟုတ်ပဲ object typeကိုပဲ ပြန်ထားတာဆိုရင်တော့ error တက်မှာဖြစ်တယ်။

toString, valueOf function 2ခုလုံးမရှိနေဘူးဆိုရင်တော့ 
number typeကိုပြောင်းရင် NaN
string typeကိုပြောင်းရင် '[Object object]'
boolean typeကိုပြောင်းရင် trueရမှာပဲဖြစ်တယ်

object ကနေ string ပြောင်းရင်လဲ object to number typeပြောင်းတဲ့ ပုံစံ အဆင့်တိုင်းလုပ်သွားမှာဖြစ်တယ်
ဒါပေမဲ့ object ကနေ boolean ပြောင်းရင်တော့ အမြဲ trueရမှာပဲဖြစ်တယ်
